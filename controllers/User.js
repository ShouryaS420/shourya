import { OAuth2Client } from "google-auth-library";
import User from "../models/User.js";
import { sendmail } from "../utils/sendmail.js";
import { sendToken } from "../utils/sendToken.js";
import Project from '../models/ProjectDetails.js';
import { deriveUiState } from "../utils/deriveUiState.js";
import Estimate from "../models/Estimate.js";
import mongoose from "mongoose";
import axios from "axios";

// Accept multiple client IDs (Web, iOS, Android)
const CLIENT_IDS = (process.env.GOOGLE_CLIENT_IDS || process.env.GOOGLE_CLIENT_ID || "")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);

const googleClient = new OAuth2Client(CLIENT_IDS[0]);

const predefinedSteps = [
    {
        title: "Initial Contact",
        description: "First interaction with the client to discuss their needs and introduce our services.",
        status: "completed",
        subSteps: []
    },
    {
        title: "Site Visit & Clarity Report",
        description:
            "On-site assessment to capture real conditions and risks (soil type, access, utilities, neighbors, bylaws). A verified report highlights must-consider items for design and BOQ (e.g., black cotton soil → soil test + pile/raft footing provision).",
        status: "ongoing-stage",
        subSteps: [
            {
                title: "Booking confirmed",
                description: "Visit scheduled in app; client receives reference and time window.",
                status: ""
            },
            {
                title: "Engineer assigned",
                description: "Assigned site engineer details shared with client.",
                status: ""
            },
            {
                title: "On-site inspection",
                description: "Measurements, photos, and observations recorded (terrain, access, water/electricity, constraints).",
                status: ""
            },
            {
                title: "Inputs captured",
                description: "Critical flags noted for BOQ: soil type, water table, setbacks, road width, staging/storage feasibility.",
                status: ""
            },
            {
                title: "Verification",
                description: "Admin reviews inputs; adds recommendations and BOQ implications (e.g., testing, foundation strategy).",
                status: ""
            },
            {
                title: "Clarity Report shared",
                description: "Final Site Visit Report published in the app for client review and next-step planning.",
                status: ""
            }
        ]
    },
    {
        title: "Design & consultation",
        description: "Collaborative design sessions with the client to finalize the project specifications and materials.",
        status: "",
        subSteps: [
            { title: "Meeting with design team", description: "Discuss initial design concepts and gather client feedback.", status: "" },
            { title: "Initial concept design & layout presentation", description: "Presentation of initial design layouts and concept boards to the client.", status: "" },
            { title: "Material & finishing discussion", description: "Finalize materials and finishes based on client preferences and budget.", status: "" },
        ]
    },
    {
        title: "Package selection & customization",
        description: "Selection of construction packages and customization options based on client preferences.",
        status: "",
        subSteps: [
            { title: "Standard package selection", description: "Choose from standard construction packages tailored to client needs.", status: "" },
            { title: "Add-ons customization", description: "Customize additional features and enhancements.", status: "" },
            // { title: "Autogenerated BOQs", description: "Generate detailed Bill of Quantities for accurate pricing.", status: "" },
            // { title: "Final cost estimation", description: "Provide final cost estimates after all selections and customizations are made.", status: "" },
        ],
    },
    {
        title: "Agreement & booking payment",
        description: "Finalize agreement details and process the booking payment to secure the project commencement.",
        status: "",
        subSteps: [
            { title: "Initial payment received", description: "Confirm receipt of initial booking payment as per the agreement.", status: "" },
            { title: "Contract sign-in", description: "Sign official project contract with the client.", status: "" },
        ],
    },
    {
        title: "Pre-construction Readiness",
        description: "Complete all pre-construction requirements and readiness checks to ensure a smooth project start.",
        status: "",
        subSteps: [
            { title: "Legal and plan liationing", description: "Handle all legal paperwork and liaise with planning authorities.", status: "" },
            { title: "Soil Testing", description: "Conduct soil testing to inform foundation strategies.", status: "" },
            { title: "Digital Survey", description: "Perform a digital survey to capture detailed site conditions.", status: "" },
            { title: "Plan approval before main drawing", description: "Secure approvals for the preliminary plans before proceeding to detailed drawings.", status: "" },
        ],
    },
    {
        title: "Final design & structural drawings",
        description: "Develop and finalize detailed architectural and structural plans for the project.",
        subSteps: [
            { title: "Final architectural drawing", description: "Complete the final architectural plans ready for construction.", status: "" },
            { title: "Structural & MEP (Mechanical, Electrical & Plumbing)", description: "Detail out all structural, mechanical, electrical, and plumbing plans.", status: "" },
            { title: "3D visualization", description: "Create 3D visualizations to help the client visualize the final project.", status: "" },
        ],
        status: "",
    },
    {
        title: "Construction KickOff",
        description: "Begin the construction phase with all preparations and initial groundwork complete.",
        subSteps: [
            { title: "Detailed work schedule shared with client", description: "Share a detailed construction schedule with the client.", status: "" },
            { title: "Material procurement begins", description: "Start the procurement of necessary materials as per the project schedule.", status: "" },
            { title: "Site safety check completed", description: "Ensure all safety measures are in place and verified before construction begins.", status: "" },
        ],
        status: "",
    },
    {
        title: "Foundation & structure",
        description: "Begin the construction phase with all preparations and initial groundwork complete.",
        subSteps: [
            { title: "Detailed work schedule shared with client", description: "Share a detailed construction schedule with the client.", status: "" },
            { title: "Material procurement begins", description: "Start the procurement of necessary materials as per the project schedule.", status: "" },
            { title: "Site safety check completed", description: "Ensure all safety measures are in place and verified before construction begins.", status: "" },
        ],
        status: "",
    },
    {
        title: "Brickwork & masonry",
        description: "Begin the construction phase with all preparations and initial groundwork complete.",
        subSteps: [
            { title: "Detailed work schedule shared with client", description: "Share a detailed construction schedule with the client.", status: "" },
            { title: "Material procurement begins", description: "Start the procurement of necessary materials as per the project schedule.", status: "" },
            { title: "Site safety check completed", description: "Ensure all safety measures are in place and verified before construction begins.", status: "" },
        ],
        status: "",
    },
    {
        title: "Internal finishing",
        description: "Begin the construction phase with all preparations and initial groundwork complete.",
        subSteps: [
            { title: "Detailed work schedule shared with client", description: "Share a detailed construction schedule with the client.", status: "" },
            { title: "Material procurement begins", description: "Start the procurement of necessary materials as per the project schedule.", status: "" },
            { title: "Site safety check completed", description: "Ensure all safety measures are in place and verified before construction begins.", status: "" },
        ],
        status: "",
    },
    {
        title: "Final touches & handover",
        description: "Begin the construction phase with all preparations and initial groundwork complete.",
        subSteps: [
            { title: "Detailed work schedule shared with client", description: "Share a detailed construction schedule with the client.", status: "" },
            { title: "Material procurement begins", description: "Start the procurement of necessary materials as per the project schedule.", status: "" },
            { title: "Site safety check completed", description: "Ensure all safety measures are in place and verified before construction begins.", status: "" },
        ],
        status: "",
    },
];

// ------- helpers -------
const isEmail = (v = "") => /\S+@\S+\.\S+/.test(String(v).trim());
const onlyDigits = (v = "") => String(v).replace(/\D/g, "");
const isTenDigitMobile = (v = "") => /^\d{10}$/.test(onlyDigits(v));

function generateUserId() {
    const prefix = "PRJ";
    const randomNumber = Math.floor(Math.random() * 10000000);
    return `${prefix}${randomNumber.toString().padStart(7, "0")}`;
}

function generateProjectId() {
    const prefix = "PRJ";
    const randomNumber = Math.floor(Math.random() * 10000000);
    return `${prefix}${randomNumber.toString().padStart(7, "0")}`;
}

// --- Google Places helpers ---
function pick(ac, type) {
    return (ac || []).find(c => (c.types || []).includes(type));
}
function normAddressComponents(components = []) {
    const city = pick(components, 'locality')?.long_name
        || pick(components, 'postal_town')?.long_name
        || pick(components, 'administrative_area_level_3')?.long_name
        || '';
    const district = pick(components, 'administrative_area_level_2')?.long_name || '';
    const stateComp = pick(components, 'administrative_area_level_1');
    const state = stateComp?.long_name || '';
    const stateCode = stateComp?.short_name || '';
    const countryComp = pick(components, 'country');
    const country = countryComp?.long_name || '';
    const countryCode = countryComp?.short_name || '';
    const postalCode = pick(components, 'postal_code')?.long_name || '';
    const sublocality = pick(components, 'sublocality')?.long_name
        || pick(components, 'sublocality_level_1')?.long_name
        || '';
    const route = pick(components, 'route')?.long_name || '';
    const streetNumber = pick(components, 'street_number')?.long_name || '';
    return { city, district, state, stateCode, country, countryCode, postalCode, sublocality, route, streetNumber };
}

function safeNumber(n) {
    const v = typeof n === 'function' ? n() : n;
    return typeof v === 'number' ? v : (v != null ? Number(v) : undefined);
}

function sanitizeRaw(details = {}) {
    if (!details || typeof details !== 'object') return undefined;
    // pick only plain-json, small bits
    const ac = Array.isArray(details.address_components)
        ? details.address_components.map(c => ({
            long_name: c.long_name, short_name: c.short_name, types: c.types
        }))
        : undefined;
    const plus = details.plus_code
        ? { global_code: details.plus_code.global_code, compound_code: details.plus_code.compound_code }
        : undefined;
    const viewport = details.geometry?.viewport
        ? {
            northeast: {
                lat: safeNumber(details.geometry.viewport?.getNorthEast?.().lat) ?? details.geometry.viewport?.northeast?.lat,
                lng: safeNumber(details.geometry.viewport?.getNorthEast?.().lng) ?? details.geometry.viewport?.northeast?.lng,
            },
            southwest: {
                lat: safeNumber(details.geometry.viewport?.getSouthWest?.().lat) ?? details.geometry.viewport?.southwest?.lat,
                lng: safeNumber(details.geometry.viewport?.getSouthWest?.().lng) ?? details.geometry.viewport?.southwest?.lng,
            },
        }
        : undefined;
    return {
        place_id: details.place_id,
        name: details.name,
        formatted_address: details.formatted_address,
        types: details.types,
        address_components: ac,
        plus_code: plus,
        geometry: {
            location: {
                lat: safeNumber(details.geometry?.location?.lat),
                lng: safeNumber(details.geometry?.location?.lng),
            },
            viewport,
        },
    };
}

function normalizePlotInfo(input = {}, fallbackLabel = '') {
    // Accept either raw Google Places Details or already-shaped object
    const isRaw = !!input?.geometry || !!input?.address_components;
    if (isRaw) {
        const lat = safeNumber(input?.geometry?.location?.lat);
        const lng = safeNumber(input?.geometry?.location?.lng);
        const viewport = input?.geometry?.viewport
            ? {
                northeast: {
                    lat: safeNumber(input.geometry.viewport?.getNorthEast?.().lat) ?? input.geometry.viewport?.northeast?.lat ?? undefined,
                    lng: safeNumber(input.geometry.viewport?.getNorthEast?.().lng) ?? input.geometry.viewport?.northeast?.lng ?? undefined,
                },
                southwest: {
                    lat: safeNumber(input.geometry.viewport?.getSouthWest?.().lat) ?? input.geometry.viewport?.southwest?.lat ?? undefined,
                    lng: safeNumber(input.geometry.viewport?.getSouthWest?.().lng) ?? input.geometry.viewport?.southwest?.lng ?? undefined,
                },
            }
            : undefined;
        const addr = normAddressComponents(input?.address_components || []);
        return {
            plotLocation: fallbackLabel || input?.name || input?.formatted_address || '',
            placeId: input?.place_id || '',
            formattedAddress: input?.formatted_address || '',
            lat, lng,
            ...addr,
            viewport,
            plusCode: input?.plus_code?.global_code || input?.plus_code?.compound_code || '',
            raw: sanitizeRaw(input), // keep a SMALL, serializable raw snapshot
        };
    }
    // already shaped; just select known keys + fallback plotLocation
    const {
        plotLocation, placeId, formattedAddress, lat, lng,
        city, district, state, stateCode, country, countryCode,
        postalCode, sublocality, route, streetNumber, viewport, plusCode, raw
    } = input || {};
    return {
        plotLocation: plotLocation || fallbackLabel || '',
        placeId, formattedAddress,
        lat: safeNumber(lat), lng: safeNumber(lng),
        city, district, state, stateCode, country, countryCode,
        postalCode, sublocality, route, streetNumber, viewport, plusCode, raw
    };
}


async function generateUniqueId(model, field, gen) {
    let attempt = 0;
    // Limit attempts to avoid infinite loop in extreme edge cases
    while (attempt < 5) {
        const candidate = gen();
        const existing = await model.findOne({ [field]: candidate }).lean();
        if (!existing) return candidate;
        attempt++;
    }
    // Fallback: append timestamp if repeated collisions (extremely unlikely)
    return `${gen()}${Date.now()}`;
}

// ---------- SMSGatewayHub OTP helper ----------

const SMSGW_BASE_URL = "https://www.smsgatewayhub.com/api/mt/SendSMS";

/**
 * Send OTP via SMSGatewayHub
 * @param {string} mobile10 - 10 digit mobile number (Indian)
 * @param {string|number} otp - OTP to send
 */
async function sendOtpSms(mobile10, otp) {
    try {
        if (!mobile10 || !/^\d{10}$/.test(String(mobile10))) {
            console.warn("sendOtpSms called with invalid mobile:", mobile10);
            return;
        }

        // ⚠️ Put your real values in env vars in production
        const API_KEY = process.env.SMSGW_API_KEY || "NH7bdthK3UmuzAjdzWlyLA"; // <- move to .env
        const SENDERID = process.env.SMSGW_SENDERID || "MBITPL";               // must be 6-char approved header
        const ROUTE = process.env.SMSGW_ROUTE || "clickhere";              // as per your account / route id
        const ENTITYID = process.env.SMSGW_ENTITY_ID || "1701176293157455251";                   // DLT EntityId
        const DLT_TEMPLATE_ID = process.env.SMSGW_OTP_TEMPLATE_ID || "1707176304331323741";      // DLT template id for this OTP SMS

        if (!API_KEY) {
            console.warn("SMSGatewayHub API key missing, skipping SMS send");
            return;
        }

        // IMPORTANT: This text MUST match your approved DLT template (with variables).
        // Example (update to your real approved template):
        const message = `Your OTP for login verification is ${otp}. Please do not share this OTP with anyone for security reasons. MBITPL`;

        const params = new URLSearchParams({
            APIKey: API_KEY,
            senderid: SENDERID,
            channel: "2",      // 2 = Transactional
            DCS: "0",          // 0 = normal text
            flashsms: "0",
            number: `91${mobile10}`, // Indian number
            text: message,
            route: ROUTE,
            EntityId: "1701176293157455251",
            dlttemplateid: "1707176304331323741"
        });

        // if (ENTITYID) params.append("EntityId", ENTITYID);
        // if (DLT_TEMPLATE_ID) params.append("dlttemplateid", DLT_TEMPLATE_ID);

        const url = `${SMSGW_BASE_URL}?${params.toString()}`;

        console.log('url:', url);

        const resp = await axios.get(url);
        // Optional: log success or check ErrorCode
        if (resp?.data?.ErrorCode !== "000") {
            console.warn("SMSGatewayHub non-success response:", resp.data);
        }
    } catch (err) {
        console.log("sendOtpSms error:", err?.response?.data || err.message);
        // We don't throw here to avoid breaking login; just log.
    }
}

/**
 * Convenience wrapper – safely extracts 10-digit mobile and calls SMS
*/
async function sendOtpIfMobile(user, otp) {
    try {
        const rawMobile =
            user?.mobile ||
            user?.signupIdentifier ||
            user?.alternateNumber;

        if (!rawMobile) return;
        const mobile10 = onlyDigits(rawMobile).slice(-10);
        if (!/^\d{10}$/.test(mobile10)) return;

        console.log(mobile10);

        await sendOtpSms(mobile10, otp);
    } catch (e) {
        console.error("sendOtpIfMobile error:", e.message);
    }
}

/**
 * Send OTP via email (for email-based login)
 */
async function sendOtpEmail(toEmailRaw, otp, opts = {}) {
    try {
        const toEmail = String(toEmailRaw || "").trim().toLowerCase();

        if (!toEmail || !isEmail(toEmail)) {
            console.warn("sendOtpEmail called with invalid email:", toEmailRaw);
            return { ok: false, reason: "invalid_email" };
        }

        const name = (opts.name || "there").trim();
        const brandName = "99Squarewall | Home Construction";
        const subject = "Your 99Squarewall login OTP";

        const text =
            `Hi ${name},

Your one-time password (OTP) for login is: ${otp}

This OTP is valid for 10 minutes. Please do not share it with anyone.

${brandName}
`;

        const html = `<!DOCTYPE html>
<html>
<head><meta charset="utf-8" /><title>${subject}</title></head>
<body style="margin:0;padding:24px;background-color:#f5f7fb;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif;">
  <table width="100%" cellpadding="0" cellspacing="0" role="presentation">
    <tr>
      <td align="center">
        <table width="100%" cellpadding="0" cellspacing="0" role="presentation" style="max-width:520px;background:#ffffff;border-radius:12px;overflow:hidden;box-shadow:0 6px 18px rgba(0,0,0,0.06);">
          <tr>
            <td style="background:#004AAD;padding:20px 24px;color:#ffffff;">
              <div style="font-size:18px;font-weight:600;">99Squarewall</div>
              <div style="font-size:12px;opacity:0.9;">Home Construction | Pune</div>
            </td>
          </tr>
          <tr>
            <td style="padding:24px 24px 8px 24px;color:#111827;font-size:14px;line-height:1.6;">
              <p style="margin:0 0 12px 0;">Hi ${name},</p>
              <p style="margin:0 0 12px 0;">Use the OTP below to securely log in to your 99Squarewall account:</p>
            </td>
          </tr>
          <tr>
            <td align="center" style="padding:8px 24px 16px 24px;">
              <div style="display:inline-block;background:#f3f4ff;border-radius:8px;padding:12px 24px;border:1px solid #d1d5ff;">
                <span style="font-size:24px;letter-spacing:4px;font-weight:700;color:#111827;">${otp}</span>
              </div>
              <p style="margin:12px 0 0 0;font-size:12px;color:#6b7280;">
                This OTP is valid for 10 minutes. Please do not share it with anyone.
              </p>
            </td>
          </tr>
          <tr>
            <td style="padding:16px 24px 24px 24px;font-size:12px;color:#6b7280;line-height:1.5;">
              <p style="margin:0 0 8px 0;">If you did not try to log in, you can safely ignore this email.</p>
              <p style="margin:0;">Regards,<br/><strong>99Squarewall Team</strong><br/>MagneticByte Internet Technologies (OPC) Pvt. Ltd.</p>
            </td>
          </tr>
        </table>
        <div style="margin-top:8px;font-size:11px;color:#9ca3af;">
          You are receiving this email because someone tried to log in using this address.
        </div>
      </td>
    </tr>
  </table>
</body>
</html>`;

        // IMPORTANT: call sendmail with an object
        await sendmail({
            to: toEmail,
            subject,
            htmlContent: html,
            text,
        });

        return { ok: true };
    } catch (err) {
        console.error("sendOtpEmail error:", err?.message || err);
        return { ok: false, reason: "send_failed", error: err?.message };
    }
}


export const googleLogin = async (req, res) => {
    try {
        const { idToken } = req.body || {};
        if (!idToken) return res.status(400).json({ success: false, message: "Missing idToken" });

        const ticket = await googleClient.verifyIdToken({
            idToken,
            audience: CLIENT_IDS.length ? CLIENT_IDS : undefined,
        });
        const payload = ticket.getPayload();
        if (!payload) return res.status(401).json({ success: false, message: "Invalid Google token" });

        const { email, name, picture, email_verified } = payload || {};
        if (!email || !isEmail(email)) {
            return res.status(400).json({ success: false, message: "Google account has no valid email" });
        }
        if (email_verified === false) {
            return res.status(400).json({ success: false, message: "Unverified Google email" });
        }

        const user = await User.findOne({ email: email.toLowerCase() });
        if (!user) {
            // Do not create yet. Ask client to collect mobile & minimal profile,
            // then call /user/register-begin which will create + send OTP to mobile.
            return res.status(200).json({
                success: true,
                code: "NEEDS_PROFILE",
                message: "Complete your profile to finish signup.",
                prefill: {
                    email,
                    name: name || "",
                    picture: picture || ""
                }
            });
        }

        // (Optional) refresh profile fields
        let changed = false;
        if (name && user.username !== name) { user.username = name; changed = true; }
        if (picture && user.img !== picture) { user.img = picture; changed = true; }
        if (changed) await user.save();

        // Issue JWT and respond
        return sendToken(res, user, 200, "Google sign-in successful");
    } catch (err) {
        console.error("googleLogin error:", err);
        return res.status(500).json({ success: false, message: `server error: ${err.message}` });
    }
};

export const login = async (req, res) => {
    try {
        const { input } = req.body || {};
        if (!input) {
            return res
                .status(400)
                .json({ success: false, message: "Please provide email or 10-digit mobile number." });
        }

        let query = {};
        let normalizedMobile = null;

        if (isEmail(input)) {
            query = { email: String(input).trim().toLowerCase() };
        } else if (isTenDigitMobile(input)) {
            normalizedMobile = onlyDigits(input).slice(-10);
            query = { mobile: normalizedMobile };
        } else {
            return res.status(400).json({ success: false, message: "Invalid email or mobile number." });
        }

        // 1) Find or create user
        let user = await User.findOne(query);
        let createdNow = false;

        if (!user) {
            // Generate unique userId for first-time users
            const userId = await generateUniqueId(User, "userId", generateUserId);

            user = await User.create({
                username: isEmail(input) ? String(input).split("@")[0] : `user_${normalizedMobile}`,
                email: isEmail(input) ? String(input).trim().toLowerCase() : undefined,
                mobile: normalizedMobile || undefined,
                userId,               // <- stable public-facing ID
                mainUserID: userId,   // <- you can keep family/household ties using this
                isApproved: true,     // allow consumer app entry
                // seed a very small skeleton so the app has data to render safely
                currentPhase: "Lead",
                progress: "0%",
                steps: predefinedSteps,
                needsProfile: true,
                signupMethod: isEmail(input) ? 'email' : 'mobile',
                signupIdentifier: isEmail(input) ? String(input).trim().toLowerCase() : normalizedMobile,
            });

            createdNow = true;

            // Seed dummy project & a minimal construction stub so UI has something to show.
            try {
                const projectId = await generateUniqueId(Project, "projectId", generateProjectId);

                // Minimal “safe” defaults. Keep it small; your UI can expand/edit later.
                const seededConstruction = {
                    selectedPackage: "Starter",
                    stage: "Lead",
                    status: "Pending",
                    requested: false,
                    meetingStarted: false,
                    packageDetails: [],
                };

                // Attach to user record
                user.constructionDetails = user.constructionDetails || [];
                user.constructionDetails.push(seededConstruction);
                await user.save();

                // Create the companion Project doc
                await Project.create({
                    projectId,
                    userMongoId: user._id,   // (if your schema has this; else remove)
                    userId: user.userId,     // human-friendly ID
                    ownerMobile: user.mobile,
                    ownerEmail: user.email,
                    constructionDetails: [seededConstruction],
                    // add any tiny defaults your UI expects:
                    projectType: user.projectType || "Home Construction",
                    status: "Pending",
                });

                // Optionally expose the generated IDs in response for client UX
                // (don’t expose in production if you prefer not to)
                req._seedInfo = { userId: user.userId, projectId };
            } catch (seedErr) {
                // Seeding is non-fatal. Log and continue the OTP flow.
                console.error("Seeding error (non-fatal):", seedErr);
            }
        } else {
            // If existing but profile is incomplete, still require profile step once
            if (!user.username || !user.plotInformation?.plotLocation) {
                user.needsProfile = true;
                await user.save();
            }
        }

        // User exists: issue OTP (no creation)
        const otp = Math.floor(1000 + Math.random() * 9000);
        user.otp = otp;
        user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000);
        await user.save();

        // Send OTP through the same channel that was used as input
        if (isEmail(input)) {
            const email = String(input).trim().toLowerCase();
            await sendOtpEmail(input, otp, { name: user.username || "there" });
        } else if (isTenDigitMobile(input)) {
            await sendOtpIfMobile(user, otp);
        }

        return res.status(200).json({
            success: true,
            exists: true,
            message: "OTP sent successfully",
            // DEV ONLY:
            otp,
        });

    } catch (error) {
        console.log("login error:", error);
        return res.status(500).json({ success: false, message: `server error: ${error.message}` });
    }
};

export const checkIdentifier = async (req, res) => {
    try {
        const { input } = req.body || {};
        if (!input) return res.status(400).json({ success: false, message: "Please provide email or 10-digit mobile number." });

        let query = {};
        if (isEmail(input)) query = { email: String(input).trim().toLowerCase() };
        else if (isTenDigitMobile(input)) query = { mobile: onlyDigits(input).slice(-10) };
        else return res.status(400).json({ success: false, message: "Invalid email or mobile number." });

        const user = await User.findOne(query);
        if (!user) {
            return res.status(200).json({ success: true, exists: false, message: "Identifier not found" });
        }

        // User exists: issue OTP (no creation)
        const otp = Math.floor(1000 + Math.random() * 9000);
        user.otp = otp;
        user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000);
        await user.save();

        // Send OTP through the same channel that was used as input
        if (isEmail(input)) {
            const email = String(input).trim().toLowerCase();
            await sendOtpEmail(input, otp, { name: user.username || "there" });
        } else if (isTenDigitMobile(input)) {
            await sendOtpIfMobile(user, otp);
        }

        return res.status(200).json({
            success: true,
            exists: true,
            message: "OTP sent successfully",
            // DEV ONLY:
            otp,
        });
    } catch (err) {
        console.error("checkIdentifier error:", err);
        return res.status(500).json({ success: false, message: `server error: ${err.message}` });
    }
};

export const registerBegin = async (req, res) => {
    try {
        const { name, email, mobile, plotLocation, plotInformation } = req.body || {};
        const hasEmail = isEmail(email || "");
        const hasMobile = isTenDigitMobile(mobile || "");
        if (!hasEmail && !hasMobile) {
            return res.status(400).json({ success: false, message: "Provide a valid email or 10-digit mobile." });
        }
        const normalizedEmail = hasEmail ? String(email).trim().toLowerCase() : undefined;
        const normalizedMobile = hasMobile ? onlyDigits(mobile).slice(-10) : undefined;

        let query = normalizedEmail ? { email: normalizedEmail } : { mobile: normalizedMobile };
        let user = await User.findOne(query);

        const normalizedPlotInfo = normalizePlotInfo(plotInformation, plotLocation);

        if (!user) {
            const userId = await generateUniqueId(User, "userId", generateUserId);
            user = await User.create({
                username: name?.trim() || (normalizedEmail ? normalizedEmail.split("@")[0] : `user_${normalizedMobile}`),
                email: normalizedEmail,
                mobile: normalizedMobile,
                userId,
                mainUserID: userId,
                isApproved: true,
                currentPhase: "Lead",
                progress: "0%",
                steps: predefinedSteps,
                needsProfile: false, // ✅ profile completed up-front
                signupMethod: normalizedEmail ? 'email' : 'mobile',
                signupIdentifier: normalizedEmail || normalizedMobile,
                plotInformation: normalizedPlotInfo,
            });
        } else {
            // If user exists but wants to complete missing profile fields before OTP, allow light patch
            if (name && !user.username) user.username = name.trim();
            if (plotLocation || plotInformation) {
                user.plotInformation = { ...(user.plotInformation?.toObject?.() || user.plotInformation || {}), ...normalizedPlotInfo };
            }
            // If now minimum profile is set, clear the gate
            if (user.username && user.plotInformation?.plotLocation) user.needsProfile = false;
            await user.save();
        }

        // Always send OTP next
        const otp = Math.floor(1000 + Math.random() * 9000);
        user.otp = otp;
        user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000);
        await user.save();

        // Send OTP via SMS (mobile is normalizedMobile here)
        await sendOtpIfMobile(user, otp);

        return res.status(200).json({
            success: true,
            message: "OTP sent successfully",
            created: true,
            exists: true,
            // DEV ONLY:
            otp,
        });
    } catch (err) {
        console.error("registerBegin error:", err);
        return res.status(500).json({ success: false, message: `server error: ${err.message}` });
    }
};

export const verifyOtp = async (req, res) => {
    try {
        const { input, otp } = req.body || {};

        if (!input || typeof otp === "undefined" || otp === null) {
            return res.status(400).json({ success: false, message: "Input and OTP are required" });
        }

        // Normalize identifier
        let query = {};
        if (isEmail(input)) {
            query = { email: String(input).trim().toLowerCase() };
        } else if (isTenDigitMobile(input)) {
            const normalizedMobile = onlyDigits(input).slice(-10);
            query = { mobile: normalizedMobile };
        } else {
            return res.status(400).json({ success: false, message: "Invalid email or mobile number" });
        }

        const user = await User.findOne(query);
        if (!user) {
            return res.status(400).json({ success: false, message: "User not found" });
        }

        // Must have an OTP in-flight
        if (!user.otp || !user.otpExpiresAt) {
            return res.status(400).json({ success: false, message: "OTP not requested" });
        }

        // Expiry check first
        if (user.otpExpiresAt < new Date()) {
            // clear stale otp
            user.otp = undefined;
            user.otpExpiresAt = undefined;
            await user.save();
            return res.status(400).json({ success: false, message: "OTP expired" });
        }

        // Compare as strings to avoid type issues
        if (String(user.otp) !== String(otp)) {
            return res.status(400).json({ success: false, message: "Invalid OTP" });
        }

        // Success — clear OTP fields
        user.otp = undefined;
        user.otpExpiresAt = undefined;
        await user.save();

        // Issue JWT & respond with your standard helper
        // (In Step 4 we'll also include token in JSON for mobile.)
        return sendToken(res, user, 200, "Login successful", {
            needsProfile: !!user.needsProfile,
            signupMethod: user.signupMethod,
            signupIdentifier: user.signupIdentifier,
        });
    } catch (error) {
        console.error("verifyOtp error:", error);
        return res.status(500).json({ success: false, message: `server error: ${error.message}` });
    }
};

export const getMyProfile = async (req, res) => {
    try {
        const user = await User.findById(req.user._id);

        sendToken(res, user, 200, `welcome back ${user.fullName}`);

    } catch (error) {
        res.status(500).send({ success: false, message: `server error: ${error.message}` });
    }
}

export const logout = async (req, res) => {
    try {
        res
            .status(200)
            .cookie("token", null, {
                expires: new Date(Date.now()),
            })
            .json({ success: true, message: "Logged out successfully" });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
};

export const addAlternatePhone = async (req, res) => {
    try {

        const { id, altPhone } = req.body;

        const user = await User.findById(id);

        if (!user) {
            return res.status(400).json({ success: false, message: "No User Found!" });
        }

        user.alternateNumber = altPhone;
        await user.save();

        res.status(200).send({ success: true, message: `Alternate Phone Number changed successfully` });

    } catch (error) {
        res.status(500).send({ success: false, message: `server error: ${error.message}` });
    }
}

export const getUserById = async (req, res) => {
    try {
        const { id } = req.params;
        const user = await User.findById(id);

        res.status(200).send({
            success: true,
            message: {
                ...user?.toObject(),
                uiState: deriveUiState(user),
            }
        });
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Error fetching post" });
    }
};

export const startWorking = async (req, res) => {
    try {
        // :userId is public userId (PRJ0000123 style)
        // :constructionId will now be the estimate identifier (humanId EST-00001 or Mongo _id)
        const { userId, constructionId: rawEstimateId } = req.params;

        // Quotation payload coming from mobile app
        const quotation = req.body?.quotation || req.body?.details || {};
        const {
            totalPackageCost,
            finalPackageCost,
            selectedPackage,
            plotArea,
            floors,
            discountType,
            discountValue,
            isDiscountApplied,
            packageDetails,
        } = quotation || {};

        // 1) Load user with this userId
        const user = await User.findOne({ userId });
        if (!user) {
            return res.status(404).json({
                success: false,
                message: "User not found for startWorking",
            });
        }

        // 2) Resolve Estimate document (humanId or _id)
        let estimateDoc = null;
        if (rawEstimateId) {
            if (rawEstimateId.startsWith("EST-")) {
                // Human readable id like EST-00012
                estimateDoc = await Estimate.findOne({ humanId: rawEstimateId });
            } else if (mongoose.isValidObjectId(rawEstimateId)) {
                // Mongo ObjectId
                estimateDoc = await Estimate.findById(rawEstimateId);
            } else {
                // Fallback – try as humanId anyway
                estimateDoc = await Estimate.findOne({ humanId: rawEstimateId });
            }
        }

        const resolvedEstimateMongoId = estimateDoc?._id?.toString() || rawEstimateId;
        const resolvedEstimateHumanId = estimateDoc?.humanId || rawEstimateId;

        // 3) Normalize values → strings/arrays so they match schema
        const normalized = {
            totalPackageCost: totalPackageCost != null ? String(totalPackageCost) : "",
            finalPackageCost:
                finalPackageCost != null
                    ? String(finalPackageCost)
                    : totalPackageCost != null
                        ? String(totalPackageCost)
                        : "",
            selectedPackage: selectedPackage != null ? String(selectedPackage) : "",
            plotArea: plotArea != null ? String(plotArea) : "",
            floors: Array.isArray(floors) ? floors : [],
            discountType: discountType || "none",
            discountValue: discountValue != null ? String(discountValue) : "0",
            isDiscountApplied: isDiscountApplied ? "true" : "false",
            packageDetails: Array.isArray(packageDetails) ? packageDetails : [],
        };

        // Target status for this action
        const nextStage = "Estimate & Quotation";
        const nextStatus = "Connecting RM";

        // 4) Upsert into user's constructionDetails[]
        if (!Array.isArray(user.constructionDetails)) {
            user.constructionDetails = [];
        }

        let cd = user.constructionDetails.find(
            (c) =>
                c.estimateHumanId === resolvedEstimateHumanId ||
                c.estimateId === resolvedEstimateMongoId
        );

        if (!cd) {
            // create a new constructionDetails row linked to this quotation
            cd = {
                ...normalized,
                estimateId: resolvedEstimateMongoId,
                estimateHumanId: resolvedEstimateHumanId,
                stage: nextStage,
                status: nextStatus,
                requested: true,
                rejected: false,
                resubmit: false,
                approved: false,
                finalApproved: false,
                meetingStarted: false,
                callCompleted: false,
                meetingType: null,
                meetingDate: null,
                meetingTime: null,
                assignedRM: null,
            };
            user.constructionDetails.push(cd);
        } else {
            // update the existing row for this quotation
            cd.totalPackageCost = normalized.totalPackageCost;
            cd.finalPackageCost = normalized.finalPackageCost;
            cd.selectedPackage = normalized.selectedPackage;
            cd.plotArea = normalized.plotArea;
            cd.floors = normalized.floors;
            cd.discountType = normalized.discountType;
            cd.discountValue = normalized.discountValue;
            cd.isDiscountApplied = normalized.isDiscountApplied;
            cd.packageDetails = normalized.packageDetails;

            cd.estimateId = resolvedEstimateMongoId;
            cd.estimateHumanId = resolvedEstimateHumanId;

            cd.stage = nextStage;
            cd.status = nextStatus;
            cd.requested = true;
            cd.rejected = false;
            cd.resubmit = false;
            cd.approved = false;
            cd.finalApproved = false;
        }

        // explicitly mark nested array changed
        user.markModified("constructionDetails");

        // 5) Update user-wide phase / progress for UI clarity
        user.currentPhase = "Estimate & Quotation";
        user.progress = "20%"; // tweak later if needed

        await user.save();

        // 6) Mirror into Project document (if exists)
        let project = await Project.findOne({ userId: user.userId });
        if (project) {
            if (!Array.isArray(project.constructionDetails)) {
                project.constructionDetails = [];
            }

            let pcd = project.constructionDetails.find(
                (c) =>
                    c.estimateHumanId === resolvedEstimateHumanId ||
                    c.estimateId === resolvedEstimateMongoId
            );

            const payload = {
                ...normalized,
                estimateId: resolvedEstimateMongoId,
                estimateHumanId: resolvedEstimateHumanId,
                stage: nextStage,
                status: nextStatus,
                requested: true,
                rejected: false,
                resubmit: false,
                approved: false,
                finalApproved: false,
            };

            if (!pcd) {
                project.constructionDetails.push(payload);
            } else {
                Object.assign(pcd, payload);
            }

            project.status = nextStatus;
            project.markModified("constructionDetails");
            await project.save();
        }

        // 7) Update Estimate document itself (status + pricing.total)
        if (estimateDoc) {
            estimateDoc.status = nextStatus;

            const finalTotalNumber = Number(normalized.finalPackageCost || normalized.totalPackageCost);
            if (!Number.isNaN(finalTotalNumber) && finalTotalNumber > 0) {
                estimateDoc.pricing = estimateDoc.pricing || {};
                estimateDoc.pricing.total = finalTotalNumber;
            }

            await estimateDoc.save();
        }

        return res.status(200).json({
            success: true,
            message:
                "Quotation sent for approval. We are connecting your Relationship Manager.",
            userId: user.userId,
            estimateId: resolvedEstimateHumanId,
            stage: nextStage,
            status: nextStatus,
            requested: true,
        });
    } catch (error) {
        console.log("startWorking error:", error);
        res
            .status(500)
            .send({ success: false, message: `server error: ${error.message}` });
    }
};

export const updateMe = async (req, res) => {
    try {
        const allowed = ['username', 'alternateNumber', 'projectType', 'img', 'email', 'mobile', 'plotInformation'];
        const patch = {};
        for (const key of allowed) {
            if (typeof req.body[key] !== 'undefined') patch[key] = req.body[key];
        }
        // normalize plotInformation if present
        if (patch.plotInformation) {
            patch.plotInformation = normalizePlotInfo(patch.plotInformation, patch.plotInformation?.plotLocation);
        }

        if (Object.keys(patch).length === 0) {
            return res.status(400).json({ success: false, message: 'No valid fields to update' });
        }

        const user = await User.findByIdAndUpdate(req.user._id, patch, { new: true });

        // If minimum profile is now present, clear the gate
        if (user.username && user.plotInformation?.plotLocation && user.needsProfile) {
            user.needsProfile = false;
            await user.save();
        }
        return res.status(200).json({ success: true, message: 'Profile updated', user });
    } catch (e) {
        console.error('updateMe error:', e);
        res.status(500).json({ success: false, message: `server error: ${e.message}` });
    }
};

